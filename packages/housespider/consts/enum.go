// Code generated by "gonum -types=HousePlatformEnum,SpiderTypeEnum"; DO NOT EDIT.
// See https://github.com/steinfletcher/gonum
package consts

import "encoding/json"
import "errors"
import "fmt"

type housePlatformInstanceJsonDescriptionModel struct {
	Name        string `json:"name"`
	Description string `json:"description"`
}

var housePlatformInstance = HousePlatformEnum{
	Ke:     "ke",
	Anjuke: "anjuke",
}

// HousePlatform is the enum that instances should be created from
type HousePlatform struct {
	name        string
	value       string
	description string
}

// Enum instances
var Ke = HousePlatform{name: "ke", value: "Ke", description: "贝壳"}
var Anjuke = HousePlatform{name: "anjuke", value: "Anjuke", description: "安居客"}

// NewHousePlatform generates a new HousePlatform from the given display value (name)
func NewHousePlatform(value string) (HousePlatform, error) {
	switch value {
	case "ke":
		return Ke, nil
	case "anjuke":
		return Anjuke, nil
	default:
		return HousePlatform{}, errors.New(
			fmt.Sprintf("'%s' is not a valid value for type", value))
	}
}

// Name returns the enum display value
func (g HousePlatform) Name() string {
	switch g {
	case Ke:
		return Ke.name
	case Anjuke:
		return Anjuke.name
	default:
		return ""
	}
}

// String returns the enum display value and is an alias of Name to implement the Stringer interface
func (g HousePlatform) String() string {
	return g.Name()
}

// Error returns the enum name and implements the Error interface
func (g HousePlatform) Error() string {
	return g.Name()
}

// Description returns the enum description if present. If no description is defined an empty string is returned
func (g HousePlatform) Description() string {
	switch g {
	case Ke:
		return "贝壳"
	case Anjuke:
		return "安居客"
	default:
		return ""
	}
}

// HousePlatformNames returns the displays values of all enum instances as a slice
func HousePlatformNames() []string {
	return []string{
		"ke",
		"anjuke",
	}
}

// HousePlatformValues returns all enum instances as a slice
func HousePlatformValues() []HousePlatform {
	return []HousePlatform{
		Ke,
		Anjuke,
	}
}

// MarshalJSON provides json serialization support by implementing the Marshaler interface
func (g HousePlatform) MarshalJSON() ([]byte, error) {
	if g.Description() != "" {
		m := housePlatformInstanceJsonDescriptionModel{
			Name:        g.Name(),
			Description: g.Description(),
		}
		return json.Marshal(m)
	}
	return json.Marshal(g.Name())
}

// UnmarshalJSON provides json deserialization support by implementing the Unmarshaler interface
func (g *HousePlatform) UnmarshalJSON(b []byte) error {
	var v interface{}
	err := json.Unmarshal(b, &v)
	if err != nil {
		return err
	}

	var value string
	switch v.(type) {
	case map[string]interface{}:
		value = v.(map[string]interface{})["name"].(string)
	case string:
		value = v.(string)
	}

	instance, createErr := NewHousePlatform(value)
	if createErr != nil {
		return createErr
	}

	g.name = instance.name
	g.value = instance.value
	g.description = instance.description

	return nil
}

type spiderTypeInstanceJsonDescriptionModel struct {
	Name        string `json:"name"`
	Description string `json:"description"`
}

var spiderTypeInstance = SpiderTypeEnum{
	Area:      "area",
	ErShou:    "ershou",
	ChengJiao: "chengjiao",
}

// SpiderType is the enum that instances should be created from
type SpiderType struct {
	name        string
	value       string
	description string
}

// Enum instances
var Area = SpiderType{name: "area", value: "Area", description: "区域"}
var ErShou = SpiderType{name: "ershou", value: "ErShou", description: "二手房"}
var ChengJiao = SpiderType{name: "chengjiao", value: "ChengJiao", description: "二手成交"}

// NewSpiderType generates a new SpiderType from the given display value (name)
func NewSpiderType(value string) (SpiderType, error) {
	switch value {
	case "area":
		return Area, nil
	case "ershou":
		return ErShou, nil
	case "chengjiao":
		return ChengJiao, nil
	default:
		return SpiderType{}, errors.New(
			fmt.Sprintf("'%s' is not a valid value for type", value))
	}
}

// Name returns the enum display value
func (g SpiderType) Name() string {
	switch g {
	case Area:
		return Area.name
	case ErShou:
		return ErShou.name
	case ChengJiao:
		return ChengJiao.name
	default:
		return ""
	}
}

// String returns the enum display value and is an alias of Name to implement the Stringer interface
func (g SpiderType) String() string {
	return g.Name()
}

// Error returns the enum name and implements the Error interface
func (g SpiderType) Error() string {
	return g.Name()
}

// Description returns the enum description if present. If no description is defined an empty string is returned
func (g SpiderType) Description() string {
	switch g {
	case Area:
		return "区域"
	case ErShou:
		return "二手房"
	case ChengJiao:
		return "二手成交"
	default:
		return ""
	}
}

// SpiderTypeNames returns the displays values of all enum instances as a slice
func SpiderTypeNames() []string {
	return []string{
		"area",
		"ershou",
		"chengjiao",
	}
}

// SpiderTypeValues returns all enum instances as a slice
func SpiderTypeValues() []SpiderType {
	return []SpiderType{
		Area,
		ErShou,
		ChengJiao,
	}
}

// MarshalJSON provides json serialization support by implementing the Marshaler interface
func (g SpiderType) MarshalJSON() ([]byte, error) {
	if g.Description() != "" {
		m := spiderTypeInstanceJsonDescriptionModel{
			Name:        g.Name(),
			Description: g.Description(),
		}
		return json.Marshal(m)
	}
	return json.Marshal(g.Name())
}

// UnmarshalJSON provides json deserialization support by implementing the Unmarshaler interface
func (g *SpiderType) UnmarshalJSON(b []byte) error {
	var v interface{}
	err := json.Unmarshal(b, &v)
	if err != nil {
		return err
	}

	var value string
	switch v.(type) {
	case map[string]interface{}:
		value = v.(map[string]interface{})["name"].(string)
	case string:
		value = v.(string)
	}

	instance, createErr := NewSpiderType(value)
	if createErr != nil {
		return createErr
	}

	g.name = instance.name
	g.value = instance.value
	g.description = instance.description

	return nil
}
